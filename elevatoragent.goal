% stupid elevator agents
% does not include other agent's believe state, elevators mostly go to the same floors because of same goals.
% elevator must be able to stop along the way if someone presses a button on a floor that is on route
% does not adapt to the destination of elevator passengers, unnecessary long in elevator 

init module {
	knowledge{
		% onRoute succeeds when Level is in the current direction Dir relative to the floor the agent is at.
		% Note that onRoute only succeeds when the elevator car is "docked", i.e. atFloor(Here) succeeds for
		% some floor (see also the belief section).
		onRoute(Level, Dir) :- atFloor(Here), dir(Dir), Diff is Level-Here, (Diff<0 -> Dir=down; Dir=up).
		elevatorFull :- people(N), capacity(M), N = M.
		assigned(A,L,D) :- received(_, assigned(A,L,D)).
		assignedToMe(L,D) :- received(_, assigned(A,L,D)),me(A).
		%when an assigned task has been completed
		serviced(L,D) :- atFloor(L), dir(D), not(fButtonOn(L,D)).
		
		nextDirection(Level,Dir):-assignedToMe(L2,D2),Distance is abs(L2-Level),not((assignedToMe(LOther,D3),
				OtherDistance is abs(OtherLevel-Level), OtherDistance<Distance) ),
				not((eButtonOn(LOther2),OtherDistance2 is abs(LOther2-Level), OtherDistance2<Distance)),Diff is L2-Level,(Diff<0 -> Dir=down;Dir=up).
		nextDirection(Level,Dir):-eButtonOn(L2),not(L2==Level),Distance is abs(L2-Level),not((assignedToMe(LOther,D3),
				OtherDistance is abs(OtherLevel-Level), OtherDistance<Distance) ),
				not((eButtonOn(LOther2),OtherDistance2 is abs(LOther2-Level), OtherDistance2<Distance)),Diff is L2-Level,(Diff<0 -> Dir=down;Dir=up).
		nextDirection(Level,up).
		%determine value of a bid to place
		highestGoal(L):-assignedToMe(L,_),not((assignedToMe(L2,_),L<L2)),not((eButtonOn(L3),L<L3)).
		highestGoal(L):-eButtonOn(L),not((assignedToMe(L2,_),L<L2)),not((eButtonOn(L3),L<L3)).
		lowestGoal(L):-assignedToMe(L,_),not((assignedToMe(L2,_),L>L2)),not((eButtonOn(L3),L>L3)).
		lowestGoal(L):-eButtonOn(L),not((assignedToMe(L2,_),L>L2)),not((eButtonOn(L3),L>L3)).
		%onRouteBetter(Level,Dir):-carPosition(Here), dir(Dir), Diff is Level-Here, (Diff<0 -> Dir=down; Dir=up),highestGoal(Lh),lowestGoal(Ll),(Dir==down -> Level>=Ll;Level=<Lh).
		%value(V,L,D):- not(assignedToMe(_,_)), carPosition(Here),floorTravelTime(FTT), V is FTT*abs(Here-L).
		%value(V,L,D):- onRouteBetter(L,D),carPosition(Here),stopTime(ST),floorTravelTime(FTT),people(N),V is (N*ST+FTT*abs(Here-L)).
		%value(V,L,D):- carPosition(Here),stopTime(ST),floorTravelTime(FTT),people(N),dir(Dir),highestGoal(Lh),lowestGoal(Ll)
		%	,(Dir==up-> Dist is (abs(Level-Lh)+abs(Lh-Here));Dist is (abs(Level-Ll)+abs(Ll-Here))),(Dir==up->(Level<Ll->StopTime is 0;StopTime is ST*N/2);(Level>Lh->StopTime is 0;StopTime is ST*N/2)).
		amountAssigned(Val):-findall(Floor,assignedToMe(Floor,_),List),length(List,Val).
		%amountAssigned(Val):-amountAssigned(Val,[]).
		%amountAssigned(Val,Checked):-assignedToMe(L2,_),not(member(L2,Checked)),amountAssigned(V,[L2|Checked]),Val is V+1.
		%amountAssigned(0,Checked):-not((assignedToMe(L2,_),not(member(L2,Checked)))).
		
		%Bid calculation, higher is worse, cases for full, empty without current tasks, 
		%Full means don't take anything
		value(9999999999999999999999999999999999999,L,D):-elevatorFull,!.
		%Empty and no assigned means be extremely eager to take it, so heavily discount your cost calculation
		value(V,L,D):-people(N),N=0,carPosition(Here),not(assignedToMe(_,_)),V is ((1/2)*abs(Here-L)),!.
		%Now come the more regular cases: A not full not empty car
		%Split this by how well requested direction matches current direction and by how location matches current direction and level combination, so check wether it's in line with current path
		%All following things currently don't' take into account that people will also get out on some stops for how the people amount weighting is done, can do that also by making a predicate that counts the amount of stops between 2 places, will need to test if this is needed
		%First the best case scenario: the assignment is for a car that wants to go in the current direction and is "behind" the place we are currently going to, aka no direction change required,
		%or we are currently at a level and the goal is in the correct direction
		%In this case the cost is estimated as the  amount of people (both in car and assigned floors, assigned floors isnt people so underestimated) divided by #2# times the stopping cost plus the time it will take to reach the floor
		value(V,L,D):-goingTo(CurTarget),carPosition(Here),dir(Dir),Dir=D,Diff is L-CurTarget, (Diff<0 -> Dir=down; Dir=up),people(N),amountAssigned(N2),V is ((N+N2)/2+abs(Here-L)),!.
		value(V,L,D):-atFloor(Here),dir(Dir),people(N),amountAssigned(N2),Dir=D,Diff is L-Here, (Diff<0 -> Dir=down; Dir=up),V is ((N+N2)/2+abs(Here-L)),!.
		%Now the case that the direction is correct overall but we have to go backwards to get the person, in that case cost is related to the cost of having to make all current inhabitants wait + the current assignments
		
		value(V,L,D):-goingTo(CurTarget),carPosition(Here),dir(Dir),Dir=D,Diff is L-CurTarget, (Diff>0 -> Dir=down; Dir=up),people(N),amountAssigned(N2),V is ((N+N2)/2+abs(Here-L)+(N+N2+1)*2*abs(Diff)),!.
		value(V,L,D):-atFloor(Here),dir(Dir),people(N),amountAssigned(N2),Dir=D,Diff is L-Here, (Diff>0 -> Dir=down; Dir=up),V is ((N+N2)/2+abs(Here-L)+(N+N2+1)*2*abs(Diff)),!.
		%Now the cases that the direction is incorrect, first the best case for this: the level is further than the current extreme anyway.
		value(V,L,D):-atFloor(Here),dir(Dir),people(N),amountAssigned(N2),not(Dir=D),Diff is L-Here, (Diff>0 -> (highestGoal(L3),L3<L,lowestGoal(L4)); (lowestGoal(L3),L3>L,highestGoal(L4))),V is ((N+N2)/2+abs(Here-L)+2*abs(Here-L4)),!.
		value(V,L,D):-goingTo(CurTarget),carPosition(Here),dir(Dir),people(N),amountAssigned(N2),not(Dir=D),Diff is L-Here, (Diff>0 -> (highestGoal(L3),L3<L,lowestGoal(L4)); (lowestGoal(L3),L3>L,highestGoal(L4))),V is ((N+N2)/2+abs(Here-L)+2*abs(Here-L4)),!.
		%Now anything that wants to go in the wrong direction but does not lay past the extreme case, assume you still go to the extreme first and then come back
		value(V,L,D):-atFloor(Here),dir(Dir),people(N),amountAssigned(N2),not(Dir=D), (Dir==up -> highestGoal(L3); lowestGoal(L3)),V is (sqrt(N+N2)/2+abs(Here-L)+2*abs(L3-L)),!.
		value(V,L,D):-goingTo(curTarget),carPosition(Here),dir(Dir),people(N),amountAssigned(N2),not(Dir=D), (Dir==up -> highestGoal(L3); lowestGoal(L3)),V is (sqrt(N+N2)/2+abs(Here-L)+2*abs(L3-L)),!.
		
		%If nothing fits just bid the worst value
		value(999999999999999999999999999999999999999,L,D).
		
		%value(9999999999999999999999999999999999999,L,D):-elevatorFull.
		%value(V,L,D):- onRoute(L,D), carPosition(Here),goingTo(GoalLevel),people(N), V is (abs(Here-L)+N*abs(GoalLevel-Here)).
		%value(V,L,D):- carPosition(Here),goingTo(GoalLevel),people(N), V is (abs(Here-L)+N*abs(GoalLevel-Here)).
		%value(V,L,D):- not(assignedToMe(L2,D2)),people(N),N=0,carPosition(Here), V is abs(Here-L).
		%value(V,L,D):- V is 99999999999999999999999999999999999999999999999999.
		
		minCostToGoTo(L):-costToGoTo(L,[],VOut1),not((costToGoTo(L,[],VOut1),VOut1>VOut2)).
		%Used to find the order of stops given the current occupants of the elevator
		costToGoTo(L,VOut):-costToGoTo(L,[],VOut).
		costToGoTo(L,Checked,VOut):-not(member(L2,Checked)),eButtonOn(L2),people(N),carPosition(Here),costToGoTo(L,[L2|Checked],V),VOut is V+N*(abs(L2-Here)-abs(L2-L)).
		costToGoTo(L,Checked,0).
		%Used to find the bid for being assigned a floor with a certain direction, this is different from above because this must include stop time and expected wait time
		costToAdd(L,Dir,Vaccu,Checked,VOut):-eButtonOn(L2),not(member(L2,Checked)),people(N),carPosition(Here),VOut is V+N*(abs(L2-Here)-abs(L2-L)).
		costToAdd(L,Dir,Vaccu,Checked,VOut):-Vout is 0,not((eButtonOn(L2),not(member(L2,Checked)))).
		
		
		%path([H|T]):- not(member(H,T)),eButtonOn(H),path(T).
		%path([H|T]):- not(member(H,T)),assignedToMe(H,D),path(T).
		%pathCost(L,VOut):-costToGoTo(L,[L|],VOut).
		costToGoTo(L,Checked,VOut):-not(member(L2,Checked)),eButtonOn(L2),people(N),carPosition(Here),costToGoTo(L,[L2|Checked],V),VOut is V+N*(abs(L2-Here)-abs(L2-L)).
		costToGoTo(L,Checked,0).
		
		%N*stoptime+N*av_difference*floortime is value of bid
		
		
		
		floorTravelTime(4400).%An estimate of the time it takes to move 1 floor in ms, used for calculating cost of plans
		stopTime(8000).%An estimate of the time a stop takes in ms, used for calculating cost of plans
		
		
	}
	
	beliefs{
		% The direction that will be shown to the people at the next stop.
		% This remains the intended direction of movement until there are no more
		% planned stops in that direction.
		dir(down).
		people(0).
		% Initially, it is unknown whether doors are open or closed.
		doorState(unknown).
		time(0).
		carPosition(0).
	}
	goals{
		atFloor(1), dir(up).
	}
	actionspec{
		% The action goto(Level, Dir) moves the elevator car to floor Level. It can
		% only be performed if the elevator car is docked and not moving, i.e.,
		% atFloor(Here) holds for some Here.
		% When the elevator arrives at the requested floor, the Dir light will turn on.
		goto(Level, Dir) {
		   pre{ atFloor(Here), dir(DirNow), doorState(closed) }
		   post{ not(dir(DirNow)), dir(Dir),goingTo(Level) }
		}
	}
}
	
main module {
	program {		
		% Select a random goal to service if the elevator is full
		if a-goal(atFloor(L), dir(D)), bel( elevatorFull ) then goto(L, D).
		
		% Goto the nearest floor that the agent wants to go to, people current in elevator first.
		
		
		
		%if a-goal( atFloor(Level), dir(Dir) ),
		%	bel( atFloor(Here), Distance is abs(Level-Here) ),
		%    not(a-goal( atFloor(OtherLevel),
		%		OtherDistance is abs(OtherLevel-Here), OtherDistance<Distance) )
		%then goto(Level, Dir).
		
		if a-goal( atFloor(Level)),
			bel( atFloor(Here), Distance is abs(Level-Here),Diff is Level-Here,(Diff<0 -> D=down; D=up)),
			not(a-goal(atFloor(Level),dir(Dir))),
		    not(a-goal( atFloor(OtherLevel),
				OtherDistance is abs(OtherLevel-Here), OtherDistance<Distance) )
		then goto(Level, D).
		
		if a-goal( atFloor(Level), dir(Dir) ),
			bel( atFloor(Here), Distance is abs(Level-Here) ),
		    not(a-goal( atFloor(OtherLevel),
				OtherDistance is abs(OtherLevel-Here), OtherDistance<Distance) )
		then goto(Level, Dir).
	}
}

event module {
	program {
		%%%%%%% Percept Processing %%%%%%%
		
		%%Percepts only send once at the start of the simulation
		if bel( percept(capacity(N)) ) then insert ( capacity(N) ).
		if bel( percept(floorCount(Floors)) ) then insert ( floorCount(Floors) ).
		if bel( percept(carPosition(Pos))), bel(carPosition(Old_Pos)) then insert ( not(carPosition(Old_Pos)), carPosition(Pos)).
		
		%% Number of people currently in the elevator
		if bel( percept(people(N))), bel(people(Old_N)) then insert ( not(people(Old_N)), people(N)).
		
		% The atFloor(Level) percept is received only when elevator has stopped at a floor Level.
		forall bel( percept(atFloor(Level)), not(atFloor(Level)) ) do insert( atFloor(Level) ).
		forall bel(percept(atFloor(_)),goingTo(Level)) do delete (goingTo(Level)).
		forall bel( atFloor(Level), not(percept(atFloor(Level))) ) do delete( atFloor(Level) ).
		
		% The doorState percept is received only if the door state has changed.
		% So we do not need to check whether the New value is different from the Old value to avoid unnecessary updates.
		forall bel( percept(doorState(New)), doorState(Old) ) do insert( not(doorState(Old)), doorState(New) ).
		
		% The fButton(Level,Dir) percept indicates that the up or down (Dir) button on floor Level has been pressed.
		forall bel( percept(fButtonOn(Level, Dir)), not(fButtonOn(Level, Dir)) ) do insert( fButtonOn(Level, Dir) ).
		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))) ) do delete( fButtonOn(Level,Dir) ) .
		
		% Create eButtonOn percept to allow for path calculation
		forall bel( percept(eButtonOn(Level))) do insert (eButtonOn(Level)).
		forall bel( eButtonOn(Level),not(percept(eButtonOn(Level)))) do delete (eButtonOn(Level)).
		
		%%%%%% Goal Processing %%%%%%
		
		% The eButton(Level) percept is received when the elevator button on floor Level has been pressed.
		% In that case, the agent will adopt a goal to service that floor. It is ASSUMED that a button for a floor is
		% pressed that is "on route", i.e. in the direction the elevator is currently travelling.
		%forall bel( percept(eButtonOn(Level)), dir(Dir) ) do adopt( atFloor(Level), dir(Dir) ).
		forall bel( percept(eButtonOn(Level)),dir(Dir)) do adopt( atFloor(Level),dir(Dir)).
		
		% adopt goal to service a floor if the manager assigns that task to the elevator.
		forall bel( assigned(A,L,D), me(A) ) do adopt (atFloor(L), dir(D)).

		
		
		
		
		
		%%%%%% Message processing %%%%%%
		% inform manager that you have completed a task
		if bel( serviced(L,D) ) then allother.sendonce(serviced(L,D)).
		% delete serviced message after floor has  been serviced
		forall bel( sent(A, serviced(L,D)), not(atFloor(L))) do delete(sent(A, serviced(L,D))).
		forall bel(received(manager,reassign(A,L,D)),me(A)) do drop(atFloor(L),dir(D))+delete(received(manager, assigned(A,L,D)))+delete(received(manager,reassign(A,L,D))).
		forall bel(received(manager,reassign(A,L,D))) do delete(received(manager, assigned(A,L,D)))+delete(received(manager,reassign(A,L,D))).
		

		% Send a bid, if the task is not already assigned
		forall bel( fButtonOn(L,D), not(assigned(A,L,D)), value(V,L,D) ) do (manager).sendonce(bid(V,L,D)).
		% delete assigned message if the floor does not need servicing
		forall bel( assigned(A,L,D), not(fButtonOn(L,D)))  do delete(received(manager, assigned(A,L,D))).
		% delete all bids for a task if it has been assigned.
		forall bel( sent(_, bid(V,L,D)), assigned(A,L,D) ) do delete(sent(manager, bid(V,L,D))).

	}
}
